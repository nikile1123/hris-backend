# HRIS Backend System

## Обзор
Данное приложение представляет собой бэкенд-систему управления персоналом (HRIS), разработанную на Kotlin с использованием Ktor, Exposed, Kodein DI и Micrometer для метрик. Для демонстрации реализована мультимодульная структура, где каждый сервис (**employees, reviews, notifications, rabbit-consumer**) собирается и деплоится отдельно, но в рамках одного репозитория. Такая организация позволяет в дальнейшем легко разделить приложение на отдельные микросервисы.

## Архитектурные решения и сервисы

### **Архитектурные решения**

#### **Мультимодульный монолит vs микросервисы**

**Мультимодульный монолит**:
- **Плюсы**: упрощённая разработка, единая кодовая база, простота локального запуска и отладки.
- **Минусы**: сложность масштабирования отдельных компонентов, потенциальные проблемы при изменениях, затрагивающих всю систему.

**Микросервисы (можно выделить в будущем)**:
- **Плюсы**: гибкое масштабирование, независимое развертывание, изоляция отказов.
- **Минусы**: сложность DevOps, необходимость надёжной коммуникации между сервисами, сложность управления данными.

Для демонстрационных целей выбран **мультимодульный монолит**, но все модули атамарны и собираются отдельно, при необходимости их легко вынести в отдельные репозитории.

Для обеспечения надежности уведомлений используется **паттерн Transactional Outbox**. При изменении данных в основных таблицах (например, создание или обновление сотрудника, создание ревью) в рамках одной транзакции добавляется запись в таблицу **outbox**, которая одновременно является аудитом. Сервис **notifications** является имплементацией Message Relay, которая считывает эти события и отправляет нотификации в RabbitMQ в соответствующие queue и с соответсвующими routing keys.
Таким образом гарантируется, что уведомление не потеряется и не продублируется. А также происходит изоляция логики занимающейся менеджментом ревью и сотрудников от логики отправки нотификаций пользователям.

---

### **Сервисы**

Приложение развёрнуто с использованием **Docker Compose**, который помимо основных сервисов содержит вспомогательные компоненты системы:

#### **Employees Service**
Отвечает за управление данными сотрудников и команд. Реализованы CRUD-операции, а также получение иерархии сотрудника (начальник, подчинённые, коллеги) и пагинация/сортировка списка сотрудников.

#### **Reviews Service**
CRUD-операции с перформанс-ревью и их и пагинация/сортировка. При создании ревью формируется событие в таблице **outbox**, которое затем используется для отправки персональных уведомлений сотруднику.

#### **Notifications Service**
Реализует паттерн **Transactional Outbox**: изменения в основных таблицах (**employees, reviews**) сопровождаются созданием записи в таблице **outbox**. Фоновый процесс (**Outbox Relay**) периодически считывает эти события и отправляет соответствующие уведомления через RabbitMQ с нужными **routing key**. Это гарантирует надёжную доставку уведомлений и повышает масштабируемость системы.

#### **Rabbit-consumer Service**
Клиент для RabbitMQ, который вычитывает сообщения из queue и выводит их в лог для демонстрации их получения.

#### **RabbitMQ**
Брокер сообщений для уведомлений.

#### **Prometheus & Grafana**
Система мониторинга и визуализации метрик. Поставляются отдельными контейнерами.

#### **Flyway**
Для версионирования и миграции базы данных.

#### **PostgreSQL**
База данных.

#### **Postgres-exporter**
Для отправки метрик базы данных в Prometheus

---

## **Схема базы данных**

### **См. скрипт миграции (db/migration/V1__init.sql)**

Для дальнейшей возможности миграций, а также версионирования базы данных используется flyway, схема составлена без привязок на фичи конкретных баз данных для удобства потенциальной миграции.


---

## **Бизнес-кейсы**

Каждый сервис содержит файлы формата `.http` с актуальными запросами, с помощью которых можно протестировать каждый из кейсов. С полным API сервисов можно ознакомиться с помощью openapi документации, которую можно найти в каждом из сервисов в `/resources/openapi`

### **1. Персональное ревью**
**Сценарий**: при создании или изменении ревью (created, updated, deleted) формируется запись в **outbox**, затем `notifications` отправляет уведомление в RabbitMQ, откуда оно дальше считывается клиентом и сотрудник получает личное уведомление.

`POST /performance_reviews`

### **2. Кадровые изменения**
**Сценарий**: при изменении данных сотрудника создаётся событие в **outbox**, которое затем передаётся команде через RabbitMQ.

**Пример запуска**: `POST /employees` – внести в систему нового сотрудника

### **3. Получение иерархии сотрудника**
**Сценарий**: запрос позволяет сотруднику получить информацию о начальнике, подчинённых и коллегах.
`GET /employees/{employee_id}/hierarchy`
Есть также запросы позволяющие получить информацию о начальнике, подчинённых и коллегах отдельно:
`GET /employees/{id}/manager`
`GET /employees/{id}/subordinates`
`GET /employees/{id}/colleagues`

---

## **Инструкция по запуску через Docker Compose**

1. **Запустить контейнеры**:
   Запустить docker-compose через Idea или:
   ```sh
   docker-compose up -d
   ```
2. **Доступ к сервисам**:
- Employees Service: `http://localhost:8081` (см. `/resources/openapi` и коллекции запросов `.http`)
- Reviews Service: `http://localhost:8082` (см. `/resources/openapi` и коллекции запросов `.http`)
- Notifications Service: `http://localhost:8083` (см. `/resources/openapi` и коллекции запросов `.http`)
- Rabbit-consumer Service: `http://localhost:8084` (нет открытых эндпоинтов, нужен только для логирования сообщений из RabbitMQ)
- RabbitMQ Management: `http://localhost:15672` (логин: `guest`, пароль: `guest`)
- Prometheus: `http://localhost:9090` (логин: `guest`, пароль: `guest`)
- Grafana: `http://localhost:3000` (логин: `admin`, пароль: `admin`, dashboards, которые я использовал лежат в /resources/dashboards)

---

## **Нагрузочное тестирование**
### **Ожидаемая нагрузка:**

- Десятки тысяч сотрудников в базе.
- Еженедельное ревью для каждого сотрудника.
- Кадровые изменения (создание, обновление, удаление) происходят несколько раз в месяц.

Для проверки производительности используется нагрузочное тестирование с помощью [k6](https://k6.io/):

- Load test: постоянное количество виртуальных пользователей, имитирующих запросы к API (создание сотрудников, получение иерархий и т.д.).
- Stress test: резкое увеличение числа запросов для определения предельной нагрузки.
- Spike test: кратковременное увеличение нагрузки для проверки устойчивости системы к резким скачкам трафика.
- Soak test: длительное тестирование при стабильной нагрузке для обнаружения проблем с утечками памяти или другими долгосрочными проблемами.

Скрипт теста можно найти в `/resources/k6_load_test`

Результаты тестирования:



## **Рекомендации по деплою и оптимизации**

### **Деплой на продакшене**
- **Load Balancer**: NGINX, HAProxy для распределения нагрузки.
- **Кэширование**: Redis для снижения нагрузки на БД.
- **Мониторинг**: Prometheus + Grafana для отслеживания метрик.
- **Отказоустойчивость**: Авто-скейлинг сервисов, репликация базы данных и RabbitMQ.

### **Оптимизация**
- **PostgreSQL**: индексы на часто запрашиваемые поля (`supervisor_id`).
- **RabbitMQ**: разные очереди для разных типов уведомлений.
- **Сервисы**: асинхронная обработка (корутины), `Transactional Outbox` для атомарности событий.

---


