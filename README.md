# **HRIS Backend System**

# **Описание проекта**

Для демонстрационных целей выбран мультимодульный монолит. При этом каждый модуль является автономным, собирается и деплоится отдельно, что позволяет при необходимости вынести их в отдельные репозитории. С точки зрения деплоя через Docker Compose система организована как набор микросервисов.

## **Transactional Outbox и уведомления**

Для обеспечения надежности доставки уведомлений используется паттерн **Transactional Outbox**. При изменении данных в основных таблицах (например, при создании или обновлении сотрудника, создании ревью) в рамках одной транзакции добавляется запись в таблицу **outbox**.

Сервис **notifications** реализует механизм Message Relay, который периодически считывает события из таблицы **outbox** и отправляет уведомления в RabbitMQ, используя соответствующие очереди и routing keys. Затем сообщения обрабатываются сервисом rabbit-consumer и выводятся в лог.

Такой подход обеспечивает:
- Гарантию, что уведомление не будет потеряно или продублировано.
- Возможность аудита событий, так как таблица **outbox** сохраняет информацию о всех изменениях.
- Изоляцию логики обработки данных (например, ревью и учета сотрудников) от логики отправки уведомлений пользователям.

---

### **Сервисы**

Приложение развёрнуто с использованием **Docker Compose**, который помимо основных сервисов содержит вспомогательные компоненты системы:

#### **Employees Service**
Отвечает за управление данными сотрудников и команд. Реализованы CRUD-операции, а также получение иерархии сотрудника (начальник, подчинённые, коллеги) и пагинация/сортировка списка сотрудников.

#### **Reviews Service**
CRUD-операции с перформанс-ревью и их и пагинация/сортировка. При создании ревью формируется событие в таблице **outbox**, которое затем используется для отправки персональных уведомлений сотруднику.

#### **Notifications Service**
Реализует паттерн **Transactional Outbox**: изменения в основных таблицах (**employees, reviews**) сопровождаются созданием записи в таблице **outbox**. Фоновый процесс (**Outbox Relay**) периодически считывает эти события и отправляет соответствующие уведомления через RabbitMQ с нужными **routing key**. Это гарантирует надёжную доставку уведомлений и повышает масштабируемость системы.

#### **Rabbit-consumer Service**
Клиент для RabbitMQ, который вычитывает сообщения из queue и выводит их в лог для демонстрации их получения.

#### **RabbitMQ**
Брокер сообщений для уведомлений.

#### **Prometheus & Grafana**
Система мониторинга и визуализации метрик. Поставляются отдельными контейнерами.

#### **Flyway**
Для версионирования и миграции базы данных.

#### **PostgreSQL**
База данных.

#### **Postgres-exporter**
Для отправки метрик базы данных в Prometheus

---

## **Схема базы данных**

### **См. скрипт миграции (db/migration/V1__init.sql)**

Для дальнейшей миграции и версионирования базы данных используется Flyway. Схема базы данных составлена без привязки к специфическим функциям конкретных СУБД, что облегчает потенциальную миграцию.
Таблица `outbox` не имеет внешних ключей для связанных таблиц. Это снижает нагрузку и блокировки в транзакциях, а также гарантирует, что события останутся доступными даже при изменении или удалении данных в основных таблицах.

![db.png](src/main/resources/pic/db.png)

---

## **Бизнес-кейсы**

Каждый сервис содержит файлы формата `.http` с актуальными запросами, с помощью которых можно протестировать каждый из кейсов. С полным API сервисов можно ознакомиться с помощью openapi документации, которую можно найти в каждом из сервисов в `/resources/openapi`

### **1. Персональное ревью**
**Сценарий**: при создании или изменении ревью (created, updated, deleted) формируется запись в **outbox**, затем `notifications` отправляет уведомление в RabbitMQ, откуда оно дальше считывается клиентом и сотрудник получает личное уведомление. Тип уведомления соответствует названию queue, routingKey уведомления соответствует паттерну `notification.review.employee.${employeeId}`

`POST /performance_reviews`

### **2. Кадровые изменения**
**Сценарий**: при изменении данных сотрудника создаётся событие в **outbox**, которое затем передаётся команде через RabbitMQ. Процесс аналогичен персональному ревью, но routingKey уведомления соответствует паттерну `notification.employee.team.${teamId}` и уведомление получает вся команда, а не персонально сотрудник.

`POST /employees` – внести в систему нового сотрудника

### **3. Получение иерархии сотрудника**
**Сценарий**: запрос позволяет сотруднику получить информацию о начальнике, подчинённых и коллегах.
`GET /employees/{employee_id}/hierarchy`
Есть также запросы позволяющие получить информацию о начальнике, подчинённых и коллегах отдельно:
`GET /employees/{id}/manager`
`GET /employees/{id}/subordinates`
`GET /employees/{id}/colleagues`

---

## **Инструкция по запуску через Docker Compose**

1. **Запустить контейнеры**:
   Запустить docker-compose через Idea или:
   ```sh
   docker-compose up -d
   ```
2. **Доступ к сервисам**:
- Employees Service: `http://localhost:8081` (см. `/resources/openapi` и коллекции запросов `.http`)
- Reviews Service: `http://localhost:8082` (см. `/resources/openapi` и коллекции запросов `.http`)
- Notifications Service: `http://localhost:8083` (см. `/resources/openapi` и коллекции запросов `.http`)
- Rabbit-consumer Service: `http://localhost:8084` (нет открытых эндпоинтов, нужен только для логирования сообщений из RabbitMQ)
- RabbitMQ Management: `http://localhost:15672` (логин: `guest`, пароль: `guest`)
- Prometheus: `http://localhost:9090` (логин: `guest`, пароль: `guest`)
- Grafana: `http://localhost:3000` (логин: `admin`, пароль: `admin`, dashboards, которые я использовал лежат в /resources/dashboards)

---

## **Нагрузочное тестирование**
### **Ожидаемая нагрузка:**

- Десятки тысяч сотрудников в базе.
- Еженедельное ревью для каждого сотрудника.
- Кадровые изменения (создание, обновление, удаление) происходят несколько раз в месяц.

Для проверки производительности используется нагрузочное тестирование с помощью [k6](https://k6.io/):

- Load test: постоянное количество виртуальных пользователей, имитирующих запросы к API (создание сотрудников, получение иерархий и т.д.).
- Stress test: резкое увеличение числа запросов для определения предельной нагрузки.
- Spike test: кратковременное увеличение нагрузки для проверки устойчивости системы к резким скачкам трафика.
- Soak test: длительное тестирование при стабильной нагрузке для обнаружения проблем с утечками памяти или другими долгосрочными проблемами.

Скрипт теста можно найти в `/resources/k6_load_test`

Результаты тестирования:

```
     ✓ employee updated
     ✓ hierarchy retrieved
     ✓ employees list retrieved
     ✓ review created

     checks.........................: 100.00% 126155 out of 126155
     data_received..................: 63 GB   91 MB/s
     data_sent......................: 31 MB   45 kB/s
     dropped_iterations.............: 192     0.277674/s
     http_req_blocked...............: avg=6.95µs   min=0s     med=3µs     max=25.96ms p(90)=6µs      p(95)=8µs     
     http_req_connecting............: avg=2.56µs   min=0s     med=0s      max=16.44ms p(90)=0s       p(95)=0s      
     http_req_duration..............: avg=222.84ms min=1.07ms med=67.39ms max=3.15s   p(90)=624.79ms p(95)=852.18ms
       { expected_response:true }...: avg=222.84ms min=1.07ms med=67.39ms max=3.15s   p(90)=624.79ms p(95)=852.18ms
     http_req_failed................: 0.00%   0 out of 136165
     http_req_receiving.............: avg=158.17ms min=5µs    med=9.35ms  max=2.96s   p(90)=467.1ms  p(95)=648.76ms
     http_req_sending...............: avg=14.66µs  min=2µs    med=12µs    max=5.66ms  p(90)=22µs     p(95)=30µs    
     http_req_tls_handshaking.......: avg=0s       min=0s     med=0s      max=0s      p(90)=0s       p(95)=0s      
     http_req_waiting...............: avg=64.65ms  min=1.05ms med=33.93ms max=1.69s   p(90)=160.86ms p(95)=235.44ms
     http_reqs......................: 136165  196.924051/s
     iteration_duration.............: avg=1.24s    min=1s     med=1.08s   max=4.15s   p(90)=1.64s    p(95)=1.88s   
     iterations.....................: 126155  182.447426/s
     vus............................: 46      min=0                max=578
     vus_max........................: 641     min=450              max=641


running (11m31.5s), 0000/0641 VUs, 126155 complete and 0 interrupted iterations
createReviews   ✓ [======================================] 0000/0246 VUs  5m0s  010.16 iters/s
soakEmployees   ✓ [======================================] 50 VUs         10m0s
spikeUpdates    ✓ [======================================] 0000/0145 VUs  30s   100.00 iters/s
stressHierarchy ✓ [======================================] 000/300 VUs    6m0s 


```
Для employees самыми дорогими запросами являются запросы на иерархию, скрин на момент стресс теста на hierarchy

Для reviews

Для Postgres (но надо учитывать, что перед load тестом был setup, который создавал 10 тысяч сотрудников, но это не пошло в зачет произваодительности)

Все проверяемые операции (обновление сотрудника, получение иерархии, получение списка сотрудников, создание ревью) проходят с 100% успешностью, ошибок HTTP нет (http_req_failed = 0%).
Среднее время отклика по всем запросам составляет около 223 мс, при этом медиана для запроса составляет 67 мс, а p90 — около 625 мс. Что вполне приемлемо для такой нагрузки.
В целом, система показывает хорошие результаты под нагрузкой, все ключевые операции работают стабильно и в пределах приемлемых временных рамок. Это говорит о том, что приложение способно выдерживать заявленную нагрузку (десятки тысяч сотрудников, еженедельные ревью и кадровые изменения) при условии, что база данных и инфраструктура также настроены оптимально для масштабируемости.



## **Рекомендации по деплою и дальнейшей оптимизации**

Системе требутеся гибкое масштабирование, соотвественно в будущем я бы вынес ее в микросервисы.

Уже сделано:
- **Пулы запросов в бд**: Prometheus + Grafana для отслеживания метрик.
- **Мониторинг**: Prometheus + Grafana для отслеживания метрик.
- **PostgreSQL**: индексы на часто запрашиваемые поля (`supervisor_id`).
- **RabbitMQ**: разные очереди для разных типов уведомлений.
- **Сервисы**: асинхронная обработка (корутины), `Transactional Outbox` для атомарности событий.


- **Load Balancer**: NGINX, HAProxy для распределения нагрузки.
- **Кэширование**: для снижения нагрузки на БД при тяжеловесных запросах на иерархии.
- **Отказоустойчивость**: Авто-скейлинг сервисов, репликация базы данных и RabbitMQ.

### **Оптимизация**



---


